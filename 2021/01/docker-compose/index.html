<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="叶琼州"><meta name=description content="叶琼州的个人博客"><meta name=keywords content="博客,blog,算法,go,golang,docker,k8s,kubernetes,武汉大学,计算机,叶琼州,yeqiongzhou"><link rel=prev href=https://yeqiongzhou.com/2020/12/leetcode1365/><link rel=canonical href=https://yeqiongzhou.com/2021/01/docker-compose/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/x-icon href=/favicon.ico><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Docker Compose 详解 | 叶琼州的代码小窝</title><meta name=title content="Docker Compose 详解 | 叶琼州的代码小窝"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yeqiongzhou.com"},"articleSection":"posts","name":"Docker Compose 详解","headline":"Docker Compose 详解","description":"前言 当我们想要同时启动一系列相互依赖的服务时，一个个依次并严格按照顺序启动就显得尤为繁琐。这时我们就可以用到 docker compose 来执行这一系列操作。 Compose Compose 是用","inLanguage":"zh-cn","author":"叶琼州","creator":"叶琼州","publisher":"叶琼州","accountablePerson":"叶琼州","copyrightHolder":"叶琼州","copyrightYear":"2021","datePublished":"2021-01-02 20:13:14 \u002b0800 \u002b0800","dateModified":"2021-01-02 20:13:14 \u002b0800 \u002b0800","url":"https:\/\/yeqiongzhou.com\/2021\/01\/docker-compose\/","wordCount":"1317","keywords":["Docker","叶琼州的代码小窝"]}</script><script async src="https://www.googletagmanager.com/gtag/js?id="></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','');</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="font_family icon-love"></i></a>&nbsp;<a href=https://yeqiongzhou.com>叶琼州的代码小窝</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>Blog</a>
<a class=menu-item href=/categories/>Categories</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/>About</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="font_family icon-love"></i></a>&nbsp;<a href=https://yeqiongzhou.com>叶琼州的代码小窝</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>Blog</a>
<a class=menu-item href=/categories/>Categories</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/>About</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">Docker Compose 详解</h1><div class=post-meta>Written by <a itemprop=name href=https://yeqiongzhou.com rel=author>叶琼州</a> with ♥
<span class=post-time>on <time datetime=1996-21-28 itemprop=datePublished>January 2, 2021</time></span>
in
<i class="font_family icon-folder"></i><span class=post-category><a href=https://yeqiongzhou.com/categories/docker%E6%89%8B%E5%86%8C/>Docker手册</a></span>
<span class=post-word-count>, 1317 words</span></div></header><div class=post-content><h3 id=前言>前言</h3><p>　　当我们想要同时启动一系列相互依赖的服务时，一个个依次并严格按照顺序启动就显得尤为繁琐。这时我们就可以用到 docker compose 来执行这一系列操作。</p><h3 id=compose>Compose</h3><p>　　Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose 您可以使用 YML 文件来配置应用程序需要的所有服务，然后使用一个命令就可以从 YML 文件配置中创建并启动所有服务。</p><h3 id=compose-使用>Compose 使用</h3><ul><li>使用 Dockerfile 定义应用程序的环境。</li><li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li><li>最后执行 docker-compose up 命令来启动并运行整个应用程序。</li></ul><h4 id=demo-dockerfile>demo Dockerfile</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> python:3.7-alpine</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /code</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> FLASK_APP app.py<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> FLASK_RUN_HOST 0.0.0.0<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apk add --no-cache gcc musl-dev linux-headers<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> requirements.txt requirements.txt<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> pip install -r requirements.txt<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> . .<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;flask&#34;</span>, <span style=color:#e6db74>&#34;run&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><ul><li><code>FROM python:3.7-alpine</code>: 从 Python 3.7 基础镜像开始构建镜像。</li><li><code>WORKDIR /code</code>: 将工作目录设置为 /code。</li><li><code>ENV FLASK_APP app.py</code>、<code>ENV FLASK_RUN_HOST 0.0.0.0</code>: 设置环境变量。</li><li><code>COPY requirements.txt requirements.txt</code>、<code>RUN pip install -r requirements.txt</code>: 复制 requirements.txt 并安装 Python 依赖项。</li><li><code>COPY . .</code>: 将 . 项目中的当前目录复制到 . 镜像中的工作目录。</li><li><code>CMD ["flask", "run"]:</code>: 容器提供默认的执行命令为：flask run。</li></ul><h4 id=docker-composeyml>docker-compose.yml</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3&#34;</span>

<span style=color:#f92672>services</span>:
  <span style=color:#f92672>mongo</span>:
    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>mongo:3.4.24-xenial</span>
    <span style=color:#f92672>command</span>: <span style=color:#ae81ff>mongod --port 27017</span>
    <span style=color:#f92672>ports</span>:
      - <span style=color:#e6db74>&#34;27017:27017&#34;</span>

  <span style=color:#f92672>demo</span>:
    <span style=color:#f92672>build</span>: <span style=color:#ae81ff>.</span>
    <span style=color:#f92672>ports</span>:
      - <span style=color:#e6db74>&#34;5000:5000&#34;</span>
    <span style=color:#f92672>depends_on</span>:
      - <span style=color:#ae81ff>mongo</span>
</code></pre></div><h4 id=构建和运行服务>构建和运行服务</h4><p><code>docker-compose up</code> ，如果您想在后台运行的话后面跟上 <code>-d</code> 参数。</p><h3 id=yml-配置参考>yml 配置参考</h3><h4 id=version>version</h4><p><code>version: "3"</code> 指定本 yml 依从的 compose 哪个版本制定的。</p><h4 id=build>build</h4><p>指定构建的参数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3&#34;</span>
<span style=color:#f92672>services</span>:
  <span style=color:#f92672>demo</span>:
    <span style=color:#f92672>build</span>:
      <span style=color:#f92672>context</span>: <span style=color:#ae81ff>./dir</span>
      <span style=color:#f92672>dockerfile</span>: <span style=color:#ae81ff>demo/Dockerfile</span>
      <span style=color:#f92672>args</span>:
        <span style=color:#f92672>buildno</span>: <span style=color:#ae81ff>1</span>
      <span style=color:#f92672>labels</span>:
        - <span style=color:#e6db74>&#34;com.example.description=yeqiongzhou demo&#34;</span>
        - <span style=color:#e6db74>&#34;com.example.department=China Shanghai&#34;</span>
        - <span style=color:#e6db74>&#34;com.example.label-with-empty-value&#34;</span>
      <span style=color:#f92672>target</span>: <span style=color:#ae81ff>prod</span>
</code></pre></div><ul><li>context: 上下文路径。</li><li>dockerfile: 指定构建镜像的 Dockerfile 文件名。</li><li>args: 添加构建参数，这是只能在构建过程中访问的环境变量。</li><li>labels: 设置构建镜像的标签。</li><li>target: 多层构建，可以指定构建哪一层。</li></ul><h4 id=command>command</h4><p><code>command: ["go", "run", "main.go"]</code> 会覆盖 Dockerfile 容器中指定的默认命令。</p><h4 id=container_name>container_name</h4><p><code>container_name: yeqiongzhou-demo</code> 指定自定义容器名称，而不是生成的默认名称。</p><h4 id=depends_on>depends_on</h4><p>设置依赖关系。</p><ul><li>docker-compose up: 以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 demo。</li><li>docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up demo 还将创建并启动 db 和 redis。</li><li>docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，demo 在 db 和 redis 之前停止。</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3&#34;</span>
<span style=color:#f92672>services</span>:
  <span style=color:#f92672>web</span>:
    <span style=color:#f92672>build</span>: <span style=color:#ae81ff>.</span>
    <span style=color:#f92672>depends_on</span>:
      - <span style=color:#ae81ff>db</span>
      - <span style=color:#ae81ff>redis</span>
  <span style=color:#f92672>redis</span>:
    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>redis</span>
  <span style=color:#f92672>db</span>:
    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>postgres</span>
</code></pre></div><h4 id=entrypoint>entrypoint</h4><p><code>entrypoint: /code/entrypoint.sh</code> 会覆盖容器默认的 entrypoint。</p><h4 id=environment>environment</h4><p>添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>environment</span>:
  <span style=color:#f92672>RACK_ENV</span>: <span style=color:#ae81ff>development</span>
  <span style=color:#f92672>SHOW</span>: <span style=color:#e6db74>&#39;true&#39;</span>
</code></pre></div><h4 id=expose>expose</h4><p>暴露端口，但不映射到宿主机，只被连接的服务访问，仅可以指定内部端口为参数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>expose</span>:
  - <span style=color:#e6db74>&#34;6666&#34;</span>
  - <span style=color:#e6db74>&#34;8888&#34;</span>
</code></pre></div><h4 id=healthcheck>healthcheck</h4><p>用于检测 docker 服务是否健康运行。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>healthcheck</span>:
  <span style=color:#f92672>test</span>: [<span style=color:#e6db74>&#34;CMD&#34;</span>, <span style=color:#e6db74>&#34;curl&#34;</span>, <span style=color:#e6db74>&#34;-f&#34;</span>, <span style=color:#e6db74>&#34;http://localhost:8888/health&#34;</span>] <span style=color:#75715e># 设置检测程序</span>
  <span style=color:#f92672>interval</span>: <span style=color:#ae81ff>60s</span> <span style=color:#75715e># 设置检测间隔</span>
  <span style=color:#f92672>timeout</span>: <span style=color:#ae81ff>10s</span> <span style=color:#75715e># 设置检测超时时间</span>
  <span style=color:#f92672>retries</span>: <span style=color:#ae81ff>3</span> <span style=color:#75715e># 设置重试次数</span>
  <span style=color:#f92672>start_period</span>: <span style=color:#ae81ff>30s</span> <span style=color:#75715e># 启动后，多少秒开始启动检测程序</span>
</code></pre></div><h4 id=image>image</h4><p>指定容器运行的镜像。以下格式都可以:</p><ul><li>image: golang</li><li>image: ubuntu:18.04</li><li>image: yeqiongzhou/demo</li><li>image: example-registry.com:5000/redis</li><li>image: a4bc65fd # 镜像id</li></ul><h4 id=logging>logging</h4><p>服务的日志记录配置。driver: 指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项:</p><ul><li>driver: &ldquo;json-file&rdquo;</li><li>driver: &ldquo;syslog&rdquo;</li><li>driver: &ldquo;none&rdquo;</li></ul><p>仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。当达到文件限制上限，会自动删除旧得文件。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>logging</span>:
  <span style=color:#f92672>driver</span>: <span style=color:#ae81ff>json-file</span>
  <span style=color:#f92672>options</span>:
    <span style=color:#f92672>max-size</span>: <span style=color:#e6db74>&#34;200k&#34;</span> <span style=color:#75715e># 单个文件大小为200k</span>
    <span style=color:#f92672>max-file</span>: <span style=color:#e6db74>&#34;10&#34;</span> <span style=color:#75715e># 最多10个文件</span>
</code></pre></div><p>syslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>logging</span>:
  <span style=color:#f92672>driver</span>: <span style=color:#ae81ff>syslog</span>
  <span style=color:#f92672>options</span>:
    <span style=color:#f92672>syslog-address</span>: <span style=color:#e6db74>&#34;tcp://192.168.0.1:1024&#34;</span>
</code></pre></div><h4 id=restart>restart</h4><ul><li>no：是默认的重启策略，在任何情况下都不会重启容器。</li><li>always：容器总是重新启动。</li><li>on-failure：在容器非正常退出时（退出状态非0），才会重启容器。</li><li>unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器。</li></ul><h4 id=volumes>volumes</h4><p>将主机的数据卷或着文件挂载到容器里。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3.7&#34;</span>
<span style=color:#f92672>services</span>:
  <span style=color:#f92672>db</span>:
    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>postgres:latest</span>
    <span style=color:#f92672>volumes</span>:
      - <span style=color:#e6db74>&#34;/localhost/postgres.sock:/var/run/postgres/postgres.sock&#34;</span>
      - <span style=color:#e6db74>&#34;/localhost/data:/var/lib/postgresql/data&#34;</span>
</code></pre></div></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>叶琼州</span></p><p class=copyright-item><span>Link:</span>
<a href=https://yeqiongzhou.com/2021/01/docker-compose/>https://yeqiongzhou.com/2021/01/docker-compose/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="font_family icon-tag"></i>Tag(s):
<span class=tag><a href=https://yeqiongzhou.com/tags/docker/>#Docker</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://yeqiongzhou.com>home</a></span></section></div><div class=post-nav><a href=https://yeqiongzhou.com/2020/12/leetcode1365/ class=prev rel=prev title=有多少小于当前数字的数字><i class="font_family icon-left"></i>&nbsp;有多少小于当前数字的数字</a></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://unpkg.com/gitalk/dist/gitalk.css><script src=https://unpkg.com/gitalk/dist/gitalk.min.js></script><script>var title=location.pathname.substr(0,50);const gitalk=new Gitalk({clientID:'abe0462addf2bb7816db',clientSecret:'302211bbfc34be3c75ec4cfa8751002e796356fa',repo:'blog',owner:'bodhiye',admin:['bodhiye'],id:title,distractionFreeMode:false});(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('gitalk-container').innerHTML='Gitalk comments not available by default when the website is previewed locally.';return;}
gitalk.render('gitalk-container');})();</script></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2019 - 2021</span>
<span class=with-love><i class="font_family icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://yeqiongzhou.com>叶琼州</a> |</span>
<a href=http://beian.miit.gov.cn/ target=_blank rel="external nofollow">赣ICP备20001186号</a> |
<span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow">Hugo</a></span></div></footer><script src=/js/vendor_no_gallery.min.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-135209530-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?8cb4aac9b76858bf912c10546e0ca16d";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script><script>(function(){var bp=document.createElement('script');var curProtocol=window.location.protocol.split(':')[0];if(curProtocol==='https'){bp.src='https://zz.bdstatic.com/linksubmit/push.js';}
else{bp.src='http://push.zhanzhang.baidu.com/push.js';}
var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script></div></body></html>