<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="叶琼州"><meta name=description content="叶琼州的个人博客"><meta name=keywords content="博客,blog,算法,go,golang,docker,k8s,kubernetes,武汉大学,计算机,叶琼州,yeqiongzhou"><link rel=prev href=https://yeqiongzhou.com/2021/04/offer50-firstuniqchar/><link rel=next href=https://yeqiongzhou.com/2021/06/offer30-minstack/><link rel=canonical href=https://yeqiongzhou.com/2021/06/offer09-stacktoqueue/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/x-icon href=/favicon.ico><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>剑指offer09-用两个栈实现队列 | 叶琼州的代码小窝</title><meta name=title content="剑指offer09-用两个栈实现队列 | 叶琼州的代码小窝"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yeqiongzhou.com"},"articleSection":"posts","name":"剑指offer09-用两个栈实现队列","headline":"剑指offer09-用两个栈实现队列","description":"题目描述 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有","inLanguage":"zh-cn","author":"叶琼州","creator":"叶琼州","publisher":"叶琼州","accountablePerson":"叶琼州","copyrightHolder":"叶琼州","copyrightYear":"2021","datePublished":"2021-06-07 00:30:00 \u002b0800 \u002b0800","dateModified":"2021-06-07 00:30:00 \u002b0800 \u002b0800","url":"https:\/\/yeqiongzhou.com\/2021\/06\/offer09-stacktoqueue\/","wordCount":"522","keywords":["Offer","叶琼州的代码小窝"]}</script><script async src="https://www.googletagmanager.com/gtag/js?id="></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','')</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="font_family icon-love"></i></a>&nbsp;<a href=https://yeqiongzhou.com>叶琼州的代码小窝</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/ title>Blog</a>
<a class=menu-item href=/categories/ title>Categories</a>
<a class=menu-item href=/tags/ title>Tags</a>
<a class=menu-item href=/about/ title>About</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="font_family icon-love"></i></a>&nbsp;<a href=https://yeqiongzhou.com>叶琼州的代码小窝</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/ title>Blog</a>
<a class=menu-item href=/categories/ title>Categories</a>
<a class=menu-item href=/tags/ title>Tags</a>
<a class=menu-item href=/about/ title>About</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">剑指offer09-用两个栈实现队列</h1><div class=post-meta>Written by <a itemprop=name href=https://yeqiongzhou.com rel=author>叶琼州</a> with ♥
<span class=post-time>on <time datetime=6996-21-712 itemprop=datePublished>June 7, 2021</time></span>
in
<i class="font_family icon-folder"></i>
<span class=post-category><a href=https://yeqiongzhou.com/categories/%E5%89%91%E6%8C%87offer/>剑指offer</a></span>
<span class=post-word-count>, 522 words</span></div></header><div class=post-content><h2 id=题目描述>题目描述</h2><p>　　用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><h2 id=示例>示例</h2><p>示例 1：</p><p>输入：
<code>["CQueue","appendTail","deleteHead","deleteHead"]</code>
<code>[[],[3],[],[]]</code>
输出：
<code>[null,null,3,-1]</code></p><p>示例 2：</p><p>输入：
<code>["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]</code>
<code>[[],[],[5],[2],[],[]]</code>
输出：
<code>[null,-1,null,null,5,2]</code></p><h2 id=限制>限制</h2><ul><li>1 &lt;= values &lt;= 10000</li><li>最多会对 appendTail、deleteHead 进行 10000 次调用</li></ul><h2 id=题解>题解</h2><p>　　本题利用两个栈模拟一个队列，第一个栈实现插入操作，第二个栈实现删除操作。栈的特点是先入后出，而队列是先进先出。利用第二个栈来保存第一个栈当前所有的元素，依次 pop 出要删除的元素，直到第二个栈为空。当第二个栈为空则又依次把第一个栈的所有元素 push 进栈。下面是模拟过程:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>　　push stack1　3   stack2
                2
                1
   pop  stack1      stack2  ~~1~~
　　　　　　　　　　　　　　　　　　2
                              3
　　push stack1　4   stack2    2
                              3
   pop  stack1  4   stack2  ~~2~~
                              3
</code></pre></div><h2 id=源码>源码</h2><h3 id=golang-实现>golang 实现</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;container/list&#34;</span>

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CQueue</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>stack1</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>List</span>
	<span style=color:#a6e22e>stack2</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>List</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Constructor</span>() <span style=color:#a6e22e>CQueue</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>CQueue</span>{
		<span style=color:#a6e22e>stack1</span>: <span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>New</span>(),
		<span style=color:#a6e22e>stack2</span>: <span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>New</span>(),
	}
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>this</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>CQueue</span>) <span style=color:#a6e22e>AppendTail</span>(<span style=color:#a6e22e>value</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>stack1</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>value</span>)
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>this</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>CQueue</span>) <span style=color:#a6e22e>DeleteHead</span>() <span style=color:#66d9ef>int</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>stack2</span>.<span style=color:#a6e22e>Len</span>() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>stack1</span>.<span style=color:#a6e22e>Len</span>() &gt; <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>stack2</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>stack1</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>stack1</span>.<span style=color:#a6e22e>Back</span>()))
		}
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>stack2</span>.<span style=color:#a6e22e>Len</span>() <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>stack2</span>.<span style=color:#a6e22e>Back</span>()
		<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>stack2</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>e</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span>.(<span style=color:#66d9ef>int</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
}
</code></pre></div><h3 id=c-实现>c++ 实现</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stack&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#75715e>// 两个栈模拟一个队列
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CQueue</span> {
    stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> stack1, stack2;
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    CQueue() {
        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>stack1.empty()) {
            stack1.pop();
        }
        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>stack2.empty()) {
            stack2.pop();
        }
    }
    
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>appendTail</span>(<span style=color:#66d9ef>int</span> value) {
        stack1.push(value);
    }
    
    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>deleteHead</span>() {
        <span style=color:#66d9ef>if</span> (stack2.empty()) {
            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>stack1.empty()) {
                stack2.push(stack1.top());
                stack1.pop();
            }
        } 
        <span style=color:#66d9ef>if</span> (stack2.empty()) {
            <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
        } <span style=color:#66d9ef>else</span> {
            <span style=color:#66d9ef>int</span> deleteItem <span style=color:#f92672>=</span> stack2.top();
            stack2.pop();
            <span style=color:#66d9ef>return</span> deleteItem;
        }
    }
};

<span style=color:#75715e>// 两个队列模拟一个栈
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CStack</span> {
    queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> queue1, queue2;
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    CStack() {
        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>queue1.empty()) {
            queue1.pop();
        }
        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>queue2.empty()) {
            queue2.pop();
        }
    }
    
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>push</span>(<span style=color:#66d9ef>int</span> value) {
        queue1.push(value);
    }
    
    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pop</span>() {
        <span style=color:#66d9ef>int</span> node;
        <span style=color:#66d9ef>while</span> (queue1.size() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>)
        {
            queue2.push(queue1.front());
            queue1.pop();
        }
        node <span style=color:#f92672>=</span> queue1.front();
        queue1.pop();
        <span style=color:#66d9ef>while</span> (queue2.size())
        {
            queue1.push(queue2.front());
            queue2.pop();
        }
        <span style=color:#66d9ef>return</span> node;
    }
};
</code></pre></div></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>叶琼州</span></p><p class=copyright-item><span>Link:</span>
<a href=https://yeqiongzhou.com/2021/06/offer09-stacktoqueue/>https://yeqiongzhou.com/2021/06/offer09-stacktoqueue/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="font_family icon-tag"></i>Tag(s):
<span class=tag><a href=https://yeqiongzhou.com/tags/offer/>#Offer</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://yeqiongzhou.com>home</a></span></section></div><div class=post-nav><a href=https://yeqiongzhou.com/2021/04/offer50-firstuniqchar/ class=prev rel=prev title=剑指offer50-第一个只出现一次的字符><i class="font_family icon-left"></i>&nbsp;剑指offer50-第一个只出现一次的字符</a>
<a href=https://yeqiongzhou.com/2021/06/offer30-minstack/ class=next rel=next title=剑指offer30-包含min函数的栈>剑指offer30-包含min函数的栈&nbsp;<i class="font_family icon-right"></i></a></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://unpkg.com/gitalk/dist/gitalk.css><script src=https://unpkg.com/gitalk/dist/gitalk.min.js></script><script>var title=location.pathname.substr(0,50);const gitalk=new Gitalk({clientID:'abe0462addf2bb7816db',clientSecret:'302211bbfc34be3c75ec4cfa8751002e796356fa',repo:'blog',owner:'bodhiye',admin:['bodhiye'],id:title,distractionFreeMode:!1});(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('gitalk-container').innerHTML='Gitalk comments not available by default when the website is previewed locally.';return}gitalk.render('gitalk-container')})()</script></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2019 - 2021</span>
<span class=with-love><i class="font_family icon-love"></i></span>
<span class=author itemprop=copyrightHolder><a href=https://yeqiongzhou.com>叶琼州</a> |</span>
<a href=http://beian.miit.gov.cn/ target=_blank rel="external nofollow">赣ICP备20001186号</a> |
<span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow">Hugo</a></span></div></footer><script src=/js/vendor_no_gallery.min.js async></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-135209530-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><script>var _hmt=_hmt||[];(function(){var a=document.createElement("script"),b;a.src="https://hm.baidu.com/hm.js?8cb4aac9b76858bf912c10546e0ca16d",b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script><script>(function(){var a=document.createElement('script'),c=window.location.protocol.split(':')[0],b;c==='https'?a.src='https://zz.bdstatic.com/linksubmit/push.js':a.src='http://push.zhanzhang.baidu.com/push.js',b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script></div></body></html>