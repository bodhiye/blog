<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Offer on 叶琼州的代码小窝</title><link>https://yeqiongzhou.com/tags/offer/</link><description>Recent content in Offer on 叶琼州的代码小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 20 Jul 2021 16:40:00 +0800</lastBuildDate><atom:link href="https://yeqiongzhou.com/tags/offer/index.xml" rel="self" type="application/rss+xml"/><item><title>剑指offer10-i-斐波那契数列</title><link>https://yeqiongzhou.com/2021/07/offer10-i-fibonacci/</link><pubDate>Tue, 20 Jul 2021 16:40:00 +0800</pubDate><guid>https://yeqiongzhou.com/2021/07/offer10-i-fibonacci/</guid><description>题目描述 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N -</description></item><item><title>剑指offer30-包含min函数的栈</title><link>https://yeqiongzhou.com/2021/06/offer30-minstack/</link><pubDate>Tue, 15 Jun 2021 23:20:00 +0800</pubDate><guid>https://yeqiongzhou.com/2021/06/offer30-minstack/</guid><description>题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例 示</description></item><item><title>剑指offer09-用两个栈实现队列</title><link>https://yeqiongzhou.com/2021/06/offer09-stacktoqueue/</link><pubDate>Mon, 07 Jun 2021 00:30:00 +0800</pubDate><guid>https://yeqiongzhou.com/2021/06/offer09-stacktoqueue/</guid><description>题目描述 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有</description></item><item><title>剑指offer50-第一个只出现一次的字符</title><link>https://yeqiongzhou.com/2021/04/offer50-firstuniqchar/</link><pubDate>Fri, 30 Apr 2021 22:23:00 +0800</pubDate><guid>https://yeqiongzhou.com/2021/04/offer50-firstuniqchar/</guid><description>题目描述 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。 示例 s = &amp;ldquo;abaccdeff&amp;rdquo; 返回 &amp;ldquo;b&amp;rdquo; s = &amp;quot;&amp;quot; 返回 &amp;quot; &amp;quot; 限制 0 &amp;lt;= s 的长度 &amp;lt;=</description></item><item><title>剑指offer29-顺时针打印矩阵</title><link>https://yeqiongzhou.com/2021/04/offer29-spiralorder/</link><pubDate>Mon, 26 Apr 2021 00:23:00 +0800</pubDate><guid>https://yeqiongzhou.com/2021/04/offer29-spiralorder/</guid><description>题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,</description></item><item><title>剑指offer05-替换空格</title><link>https://yeqiongzhou.com/2021/04/offer05-replacespace/</link><pubDate>Mon, 12 Apr 2021 00:05:00 +0800</pubDate><guid>https://yeqiongzhou.com/2021/04/offer05-replacespace/</guid><description>题目描述 请实现一个函数，把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;。 示例 输入：s = &amp;ldquo;We are happy.&amp;rdquo; 输出：&amp;ldquo;We%20are</description></item><item><title>剑指offer04-二维数组中的查找</title><link>https://yeqiongzhou.com/2021/04/offer04-findnumberin2darray/</link><pubDate>Mon, 05 Apr 2021 23:52:00 +0800</pubDate><guid>https://yeqiongzhou.com/2021/04/offer04-findnumberin2darray/</guid><description>题目描述 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一</description></item><item><title>剑指offer03——数组中重复的数字</title><link>https://yeqiongzhou.com/2021/03/offer03-findrepeatnumber/</link><pubDate>Sun, 21 Mar 2021 16:52:00 +0800</pubDate><guid>https://yeqiongzhou.com/2021/03/offer03-findrepeatnumber/</guid><description>题目描述 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几</description></item><item><title>剑指offer66——机器人的运动范围</title><link>https://yeqiongzhou.com/2019/03/offer66/</link><pubDate>Wed, 06 Mar 2019 19:23:25 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer66/</guid><description>题目描述 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列</description></item><item><title>剑指offer65——矩阵中的路径</title><link>https://yeqiongzhou.com/2019/03/offer65/</link><pubDate>Wed, 06 Mar 2019 19:23:21 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer65/</guid><description>题目描述 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向</description></item><item><title>剑指offer64——滑动窗口的最大值</title><link>https://yeqiongzhou.com/2019/03/offer64/</link><pubDate>Wed, 06 Mar 2019 19:23:18 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer64/</guid><description>题目描述 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3</description></item><item><title>剑指offer63——数据流中的中位数</title><link>https://yeqiongzhou.com/2019/03/offer63/</link><pubDate>Wed, 06 Mar 2019 19:23:13 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer63/</guid><description>题目描述 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数</description></item><item><title>剑指offer62——二叉搜索树的第k个结点</title><link>https://yeqiongzhou.com/2019/03/offer62/</link><pubDate>Wed, 06 Mar 2019 19:23:07 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer62/</guid><description>题目描述 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 题解 #include &amp;lt;iostream&amp;gt;#include</description></item><item><title>剑指offer61——序列化二叉树</title><link>https://yeqiongzhou.com/2019/03/offer61/</link><pubDate>Wed, 06 Mar 2019 19:23:03 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer61/</guid><description>题目描述 请实现两个函数，分别用来序列化和反序列化二叉树 题解 #include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt; using namespace std; struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } TreeNode() {} }; TreeNode *newTree() { TreeNode *node = new TreeNode; int x; cin &amp;gt;&amp;gt; x;</description></item><item><title>剑指offer60——把二叉树打印成多行</title><link>https://yeqiongzhou.com/2019/03/offer60/</link><pubDate>Wed, 06 Mar 2019 19:23:00 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer60/</guid><description>题目描述 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 题解 #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } TreeNode() {} }; TreeNode *newTree()</description></item><item><title>剑指offer59——按之字形顺序打印二叉树</title><link>https://yeqiongzhou.com/2019/03/offer59/</link><pubDate>Wed, 06 Mar 2019 19:22:54 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer59/</guid><description>题目描述 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他</description></item><item><title>剑指offer58——对称的二叉树</title><link>https://yeqiongzhou.com/2019/03/offer58/</link><pubDate>Wed, 06 Mar 2019 19:22:51 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer58/</guid><description>题目描述 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; struct TreeNode { int</description></item><item><title>剑指offer57——二叉树的下一个结点</title><link>https://yeqiongzhou.com/2019/03/offer57/</link><pubDate>Wed, 06 Mar 2019 19:22:48 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer57/</guid><description>题目描述 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针</description></item><item><title>剑指offer56——删除链表中重复的结点</title><link>https://yeqiongzhou.com/2019/03/offer56/</link><pubDate>Wed, 06 Mar 2019 19:22:44 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer56/</guid><description>题目描述 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&amp;gt;2-&amp;gt;3</description></item><item><title>剑指offer55——链表中环的入口结点</title><link>https://yeqiongzhou.com/2019/03/offer55/</link><pubDate>Wed, 06 Mar 2019 19:22:40 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer55/</guid><description>题目描述 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} ListNode() {} }; ListNode *newList() { ListNode *L =</description></item><item><title>剑指offer54——字符流中第一个不重复的字符</title><link>https://yeqiongzhou.com/2019/03/offer54/</link><pubDate>Wed, 06 Mar 2019 19:22:36 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer54/</guid><description>题目描述 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&amp;quot;go&amp;quot;时，第一个只出现</description></item><item><title>剑指offer53——表示数值的字符串</title><link>https://yeqiongzhou.com/2019/03/offer53/</link><pubDate>Wed, 06 Mar 2019 19:22:32 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer53/</guid><description>题目描述 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&amp;quot;+100&amp;quot;,&amp;ldquo;5e2&amp;rd</description></item><item><title>剑指offer52——正则表达式匹配</title><link>https://yeqiongzhou.com/2019/03/offer52/</link><pubDate>Wed, 06 Mar 2019 19:22:27 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer52/</guid><description>题目描述 请实现一个函数用来匹配包括'.&amp;lsquo;和&amp;rsquo;&amp;lsquo;的正则表达式。模式中的字符&amp;rsquo;.&amp;lsquo;表</description></item><item><title>剑指offer51——构建乘积数组</title><link>https://yeqiongzhou.com/2019/03/offer51/</link><pubDate>Wed, 06 Mar 2019 19:22:23 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer51/</guid><description>题目描述 给定一个数组A[0,1,&amp;hellip;,n-1],请构建一个数组B[0,1,&amp;hellip;,n-1],其中B中的元素B[i]=A</description></item><item><title>剑指offer49——把字符串转换成整数</title><link>https://yeqiongzhou.com/2019/03/offer49/</link><pubDate>Wed, 06 Mar 2019 19:22:15 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer49/</guid><description>题目描述 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求</description></item><item><title>剑指offer48——不用加减乘除做加法</title><link>https://yeqiongzhou.com/2019/03/offer48/</link><pubDate>Wed, 06 Mar 2019 19:22:11 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer48/</guid><description>题目描述 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; int Add(int num1, int num2) { while (num2) { int carry = num1 ^num2; num2 = (num1 &amp;amp; num2) &amp;lt;&amp;lt;</description></item><item><title>剑指offer47——求1+2+3+...+n</title><link>https://yeqiongzhou.com/2019/03/offer47/</link><pubDate>Wed, 06 Mar 2019 19:22:07 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer47/</guid><description>题目描述 求1+2+3+&amp;hellip;+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断</description></item><item><title>剑指offer46——孩子们的游戏(圆圈中最后剩下的数)</title><link>https://yeqiongzhou.com/2019/03/offer46/</link><pubDate>Wed, 06 Mar 2019 19:22:03 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer46/</guid><description>题目描述 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个</description></item><item><title>剑指offer45——扑克牌顺子</title><link>https://yeqiongzhou.com/2019/03/offer45/</link><pubDate>Wed, 06 Mar 2019 19:22:00 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer45/</guid><description>题目描述 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)&amp;hellip;他随机从中抽</description></item><item><title>剑指offer44——翻转单词顺序列</title><link>https://yeqiongzhou.com/2019/03/offer44/</link><pubDate>Wed, 06 Mar 2019 19:21:57 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer44/</guid><description>题目描述 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向F</description></item><item><title>剑指offer43——左旋转字符串</title><link>https://yeqiongzhou.com/2019/03/offer43/</link><pubDate>Wed, 06 Mar 2019 19:21:52 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer43/</guid><description>题目描述 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请</description></item><item><title>剑指offer42——和为S的两个数字</title><link>https://yeqiongzhou.com/2019/03/offer42/</link><pubDate>Wed, 06 Mar 2019 19:21:43 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer42/</guid><description>题目描述 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出</description></item><item><title>剑指offer41——和为S的连续正数序列</title><link>https://yeqiongzhou.com/2019/03/offer41/</link><pubDate>Wed, 06 Mar 2019 19:21:39 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer41/</guid><description>题目描述 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少</description></item><item><title>剑指offer40——数组中只出现一次的数字</title><link>https://yeqiongzhou.com/2019/03/offer40/</link><pubDate>Wed, 06 Mar 2019 19:21:33 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer40/</guid><description>题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。 题解 #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; void FindNumsAppearOnce(vector&amp;lt;int&amp;gt; data, int* num1, int *num2) { int res =</description></item><item><title>剑指offer39——平衡二叉树</title><link>https://yeqiongzhou.com/2019/03/offer39/</link><pubDate>Wed, 06 Mar 2019 19:21:25 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer39/</guid><description>题目描述 输入一棵二叉树，判断该二叉树是否是平衡二叉树。 题解 #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cmath&amp;gt; using namespace std; struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} TreeNode() {} }; TreeNode* newTree() { TreeNode* node = new TreeNode; int x; cin &amp;gt;&amp;gt; x;</description></item><item><title>剑指offer38——二叉树的深度</title><link>https://yeqiongzhou.com/2019/03/offer38/</link><pubDate>Wed, 06 Mar 2019 19:21:22 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer38/</guid><description>题目描述 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 题解 #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt; using</description></item><item><title>剑指offer37——数字在排序数组中出现的次数</title><link>https://yeqiongzhou.com/2019/03/offer37/</link><pubDate>Wed, 06 Mar 2019 19:21:19 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer37/</guid><description>题目描述 统计一个数字在排序数组中出现的次数。 题解 #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; int binarySearch(vector&amp;lt;int&amp;gt; data, int left, int right, int k) { while (left &amp;lt;= right) { int mid = (left + right) &amp;gt;&amp;gt; 1; if (k == data[mid]) return mid; else if (k &amp;lt; data[mid]) right = mid - 1; else</description></item><item><title>剑指offer36——两个链表的第一个公共结点</title><link>https://yeqiongzhou.com/2019/03/offer36/</link><pubDate>Wed, 06 Mar 2019 19:21:15 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer36/</guid><description>题目描述 输入两个链表，找出它们的第一个公共结点。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; struct ListNode { int val; ListNode* next; ListNode(int x) :val(x), next(NULL) {} ListNode() {} }; ListNode* newList() { ListNode* L = new ListNode; L-&amp;gt;next = NULL; ListNode* q = L; int n; cin &amp;gt;&amp;gt; n; for (int i =</description></item><item><title>剑指offer35——数组中的逆序对</title><link>https://yeqiongzhou.com/2019/03/offer35/</link><pubDate>Wed, 06 Mar 2019 19:21:13 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer35/</guid><description>题目描述 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P</description></item><item><title>剑指offer33——丑数</title><link>https://yeqiongzhou.com/2019/03/offer33/</link><pubDate>Wed, 06 Mar 2019 19:21:06 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer33/</guid><description>题目描述 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做</description></item><item><title>剑指offer32——把数组排成最小的数</title><link>https://yeqiongzhou.com/2019/03/offer32/</link><pubDate>Wed, 06 Mar 2019 19:21:03 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer32/</guid><description>题目描述 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印</description></item><item><title>剑指offer31——整数中1出现的次数（从1到n整数中1出现的次数）</title><link>https://yeqiongzhou.com/2019/03/offer31/</link><pubDate>Wed, 06 Mar 2019 19:20:59 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer31/</guid><description>题目描述 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、1</description></item><item><title>剑指offer30——连续子数组的最大和</title><link>https://yeqiongzhou.com/2019/03/offer30/</link><pubDate>Wed, 06 Mar 2019 19:20:55 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer30/</guid><description>题目描述 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的</description></item><item><title>剑指offer29——最小的K个数</title><link>https://yeqiongzhou.com/2019/03/offer29/</link><pubDate>Wed, 06 Mar 2019 19:20:51 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer29/</guid><description>题目描述 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 题解 #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;</description></item><item><title>剑指offer28——数组中出现次数超过一半的数字</title><link>https://yeqiongzhou.com/2019/03/offer28/</link><pubDate>Wed, 06 Mar 2019 19:20:47 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer28/</guid><description>题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于</description></item><item><title>剑指offer27——字符串的排列</title><link>https://yeqiongzhou.com/2019/03/offer27/</link><pubDate>Wed, 06 Mar 2019 19:20:44 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer27/</guid><description>题目描述 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc</description></item><item><title>剑指offer26——二叉搜索树与双向链表</title><link>https://yeqiongzhou.com/2019/03/offer26/</link><pubDate>Wed, 06 Mar 2019 19:20:41 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer26/</guid><description>题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; struct TreeNode</description></item><item><title>剑指offer25——复杂链表的复制</title><link>https://yeqiongzhou.com/2019/03/offer25/</link><pubDate>Wed, 06 Mar 2019 19:20:38 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer25/</guid><description>题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的</description></item><item><title>剑指offer24——二叉树中和为某一值的路径</title><link>https://yeqiongzhou.com/2019/03/offer24/</link><pubDate>Wed, 06 Mar 2019 19:20:35 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer24/</guid><description>题目描述 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结</description></item><item><title>剑指offer23——二叉搜索树的后序遍历序列</title><link>https://yeqiongzhou.com/2019/03/offer23/</link><pubDate>Wed, 06 Mar 2019 19:20:31 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer23/</guid><description>题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不</description></item><item><title>剑指offer22——从上往下打印二叉树</title><link>https://yeqiongzhou.com/2019/03/offer22/</link><pubDate>Wed, 06 Mar 2019 19:20:28 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer22/</guid><description>题目描述 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 题解 #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} TreeNode() {} }; TreeNode* newTree() { TreeNode* node = new TreeNode; int x; cin</description></item><item><title>剑指offer21——栈的压入、弹出序列</title><link>https://yeqiongzhou.com/2019/03/offer21/</link><pubDate>Wed, 06 Mar 2019 19:20:24 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer21/</guid><description>题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2</description></item><item><title>剑指offer18——二叉树的镜像</title><link>https://yeqiongzhou.com/2019/03/offer18/</link><pubDate>Wed, 06 Mar 2019 19:20:12 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer18/</guid><description>题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述 二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \</description></item><item><title>剑指offer17——树的子结构</title><link>https://yeqiongzhou.com/2019/03/offer17/</link><pubDate>Wed, 06 Mar 2019 19:20:08 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer17/</guid><description>题目描述 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 题解 #include &amp;lt;iostream&amp;gt; using namespace std; struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) :</description></item><item><title>剑指offer16——合并两个排序的链表</title><link>https://yeqiongzhou.com/2019/03/offer16/</link><pubDate>Wed, 06 Mar 2019 19:20:03 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer16/</guid><description>题目描述 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; struct ListNode { int val; ListNode *next; ListNode(int x) :val(x), next(NULL) {} ListNode()</description></item><item><title>剑指offer15——反转链表</title><link>https://yeqiongzhou.com/2019/03/offer15/</link><pubDate>Wed, 06 Mar 2019 19:20:00 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer15/</guid><description>题目描述 输入一个链表，反转链表后，输出新链表的表头。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; struct ListNode { int val; ListNode *next; ListNode(int x) :val(x), next(NULL) {} ListNode() {} }; ListNode *ReverseList(ListNode *pHead) { if (pHead == NULL) return NULL; ListNode *pre = NULL, *next = NULL; while (pHead != NULL) {</description></item><item><title>剑指offer14——链表中倒数第k个结点</title><link>https://yeqiongzhou.com/2019/03/offer14/</link><pubDate>Wed, 06 Mar 2019 19:19:57 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer14/</guid><description>题目描述 输入一个链表，输出该链表中倒数第k个结点。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; struct ListNode { int val; ListNode *next; ListNode(int x) :val(x), next(NULL) {} ListNode() {} }; ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) { ListNode *p, *q; p = q = pListHead; int i = 0; for (; p !=</description></item><item><title>剑指offer13——调整数组顺序使奇数位于偶数前面</title><link>https://yeqiongzhou.com/2019/03/offer13/</link><pubDate>Wed, 06 Mar 2019 19:19:51 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer13/</guid><description>题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和</description></item><item><title>剑指offer12——数值的整数次方</title><link>https://yeqiongzhou.com/2019/03/offer12/</link><pubDate>Wed, 06 Mar 2019 19:19:48 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer12/</guid><description>题目描述 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; double power(double base, int</description></item><item><title>剑指offer11——二进制中1的个数</title><link>https://yeqiongzhou.com/2019/03/offer11/</link><pubDate>Wed, 06 Mar 2019 19:19:42 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer11/</guid><description>题目描述 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; int NumberOf1(int n) { int count = 0; while (n != 0) { count++; n = n &amp;amp; (n - 1); } return count; } int main()</description></item><item><title>剑指offer10——矩形覆盖</title><link>https://yeqiongzhou.com/2019/03/offer10/</link><pubDate>Wed, 06 Mar 2019 19:19:37 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer10/</guid><description>题目描述 我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 题解 #include &amp;lt;iostream&amp;gt;</description></item><item><title>剑指offer9——变态跳台阶</title><link>https://yeqiongzhou.com/2019/03/offer9/</link><pubDate>Wed, 06 Mar 2019 19:19:33 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer9/</guid><description>题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; int jumpFloor(int number) {</description></item><item><title>剑指offer8——跳台阶</title><link>https://yeqiongzhou.com/2019/03/offer8/</link><pubDate>Wed, 06 Mar 2019 19:19:30 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer8/</guid><description>题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 题解 #include &amp;lt;iostream&amp;gt; using namespace std;</description></item><item><title>剑指offer7——斐波那契数列</title><link>https://yeqiongzhou.com/2019/03/offer7/</link><pubDate>Wed, 06 Mar 2019 19:19:26 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer7/</guid><description>题目描述 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&amp;lt;=39 题解 #include &amp;lt;iostream&amp;gt; using namespace std; int dp[40]; int Fibonacci(int n) { if</description></item><item><title>剑指offer6——旋转数组的最小数字</title><link>https://yeqiongzhou.com/2019/03/offer6/</link><pubDate>Wed, 06 Mar 2019 19:19:22 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer6/</guid><description>题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组</description></item><item><title>剑指offer4——重建二叉树</title><link>https://yeqiongzhou.com/2019/03/offer4/</link><pubDate>Wed, 06 Mar 2019 19:19:14 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer4/</guid><description>题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列</description></item><item><title>剑指offer3——从尾到头打印链表</title><link>https://yeqiongzhou.com/2019/03/offer3/</link><pubDate>Wed, 06 Mar 2019 19:19:09 +0800</pubDate><guid>https://yeqiongzhou.com/2019/03/offer3/</guid><description>题目描述 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 题解 #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; vector&amp;lt;int&amp;gt; dev; stack&amp;lt;int&amp;gt; s; struct ListNode { int val; ListNode* next; ListNode(int x) :val(x), next(NULL) {} ListNode() {} }; vector&amp;lt;int&amp;gt; printListFromTailToHead(ListNode* head) { /*if (head</description></item></channel></rss>